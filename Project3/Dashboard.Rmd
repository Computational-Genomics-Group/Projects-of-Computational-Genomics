---
title: "Group3 -- Ex3"
output: html_document
---
#flexdashboard::flex_dashboard:
#orientation: columns
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE)
```


```{r include = FALSE}
if (!requireNamespace("devtools", quietly = TRUE))  install.packages("devtools")
library(devtools)

if (!requireNamespace("BiocManager", quietly = TRUE))  install.packages("BiocManager")
if (!requireNamespace("metagenomeSeq", quitely = TRUE )) BiocManager::install("metagenomeSeq")
library(metagenomeSeq)
if (!requireNamespace("GUniFrac", quietly = TRUE))  install.packages("GUniFrac")
library(GUniFrac)
if (!requireNamespace("glmnet", quietly = TRUE))  install.packages("glmnet")
library(glmnet)
if (!requireNamespace("Matrix", quietly = TRUE))  install.packages("Matrix")
library(Matrix)
if (!requireNamespace("mbImpute", quietly = TRUE))  install_github("ruochenj/mbImpute/mbImpute R package")
library(mbImpute)
if(!require(compositions)) install.packages(compositions)
library(compositions)
library(parallel)
if(!requireNamespace("GMPR",quitely = TRUE)) install_github("lichen-lab/GMPR")
library(GMPR)
#BiocManager::install("M3C")
library(M3C)
#BiocManager::install("umap")
library(umap)
#BiocManager::install("vegan")
library(vegan)
```

# Intro {.sidebar}

This dashboard covers:

-   Data descirption

-   Description Transformations with different reusults

-   Cumulative Sum Scaling (CSS) and Geometric Mean of Pairwise Ratios (GMPR)

-   Zero imputation with mbImpute

-   DA analysis

# Data
## Column 1

```{r,quiet=TRUE}
FEATURE_TABLE.filename="Genus_otu_table.txt"
FEATURE_TABLE=as.matrix(read.table(FEATURE_TABLE.filename, sep = "\t"))
ft=FEATURE_TABLE

METADATA.filename="metadata_table.txt"
METADATA=read.table(METADATA.filename, header = TRUE, sep ="\t", row.names = 1)
METADATA.annotdf=as(METADATA,"AnnotatedDataFrame")

tot_zeros<- sum(FEATURE_TABLE==0)
paste("Sparsity =", round(tot_zeros/length(FEATURE_TABLE)*100, digits = 1))
```
### OTU counts
OTU count table sourced from file `r FEATURE_TABLE.filename`. 
It contains 166 Samples and 245 features (represented by taxa_id).
```{r echo = FALSE}
head(FEATURE_TABLE[,1:5])
```

### METADATA
We have also a metadata file (`r METADATA.filename`) 
```{r echo = FALSE, results = 'asis'}
library(knitr)
kable(METADATA[1:5,])
```

# Isomorphism
##
### Additive Log Ratio (alr)

$${\displaystyle \operatorname {alr} (x)=\left(\log {\frac {x_{1}}{x_{D}}}\right)_i}$$

```{r}
my.alr <- function (data){
  # select reference | 
  is.ok = data>0 & is.finite(data)
  data = ifelse(is.ok, data, NA)

  num.zero = apply(is.na(data),MARGIN=1,FUN=sum) #Count number of zeroes by row
  r = which.min(num.zero)                    #Index corresponding to row with lowest number of zeroes
  #cat(sprintf("Reference taxa is the %d (%s) with %d zero \n\n",r, rownames(DATA)[r],  num.zero[r])) 
  
  out=data
  #problem we haven't a taxa present in all the sample we have to replace 0's with 1's. Also, I am going to     use as reference the one with lower number of 0's 
  for (i in 1:ncol(data)){
    out[,i]=log(data[,i] / data[r,i]) 
  }
  out[is.na(out)]=-Inf # TODO replace "replace NA" with "replace 0" where !is.ok
  return(out)
}

myalr.findreference <- function(DATA){
  num.zero = rowSums(DATA==0)
  r = which.min(num.zero)
  r[1]
}
```

```{r}
head(alr(ft)[,1:5])
num.zero = rowSums(FEATURE_TABLE==0)
```


### Central Log Ratio clr

$${\displaystyle clr(x)=\left(\log x_i-\frac 1 {nt} \sum_{j=1}^{nt}\log x_j\right)_i=\log\left(\frac{x_i}{\left(\Pi_{j=1}^{nt}x_j\right)^\frac1{nt}}\right)_i}$$

```{r}
my.clr <- function (data){
  np = dim(data)[2] 
  nt = dim(data)[1]
  out = data 
  is.ok = !(data==0 | is.na(data) | is.infinite(data))
  data[!is.ok]=NA
  
  for (i in (1:np)) {
    out[,i]<- ifelse(is.ok[,i]  
     , log2(data[,i]) - sum(log2(data[,i]), na.rm = TRUE) / sum(is.ok[,i]) 
     , 0)
  } 
  out
}
```

```{r}
#ft.clr=as.matrix(my.clr(FEATURE_TABLE))
ft.clr=as.matrix(t(clr(t(FEATURE_TABLE))))
colnames(ft.clr)=colnames(FEATURE_TABLE)
rownames(ft.clr)=rownames(FEATURE_TABLE)
head(ft.clr[,1:5])
```
### Comparison with original data
From this small sample we can clearly see that clr better represents our data: similar counts in the original data table are similarly represented in clr whether alr presents some incongrouences. One notable example is that, in $s_3$, $tax_36$ and $tax_73$ magnitudes are inverted ($tax\_36<tax\_73$ in original data and in clr but $tax\_36>tax\_73$ in alr). Clr works better than alt in count table with high sparsity


Since both ALDEx2 and ANCOM perform clr automatically, we did not perform this type of transformation before applying the two algorithms, it would introduce bias.

# Zero Imputation
## Column 2 {data-width="700"}

### How it works 


```{r}
mbimpute.pipeline<- function(DATA,METADATA, unnormalized=T){
  mbImpute.matrices = mbImpute(
    condition = METADATA$DiseaseState
    , otu_tab = t(DATA)
    , metadata=METADATA
    , unnormalized = unnormalized
    , parallel = TRUE, ncores=detectCores() )
  mbImpute.matrices
}
ft.mbimputed=mbimpute.pipeline(FEATURE_TABLE,METADATA)


```

`mbImpute` aims to impute likely false zero counts or low counts for a normalized OTU table of dimension $n * m$. Where $n$ is the number of biological samples and $m$ is the number of taxa. 

In order to achieve our goal, we will borrow information from covariate matrix of dimension $n * p$ 

The final result of the mbImpute function will output an imputed matrix of dimension n * m, which is exactly the same dimension as the input.

In particular will be produced three matrices:
`imp_count_mat_lognorm`: imputed normalized and log transformed matrix
```{r}
ft.mbimpute.origlibsize=t(ft.mbimputed$imp_count_mat_origlibsize)
head(ft.mbimpute.origlibsize[,1:5])
```

## Column 1 {data-width="300"}

### Problems

Code provided in the github repository `ruochenj/mbImpute` (from the original 
authors) presents a bug:
* if provided normalized data (`unnormalized=FALSE`) mbImpute will not scale data. This lead to incorrect imputation. 


### Compromise
We ingested mbImputed with unnormalized data and proceeded with transformation (clr) and normalization after the imputation.

# Normalization

### Cumulative Sum Scaling CSS
CSS with clr transformed data does not work well since it produces many NaN values, even where not originally present in the clr transformed data. So we decided to not 
```{r echo=FALSE}
css.pipeline<- function(data, mtdata){
  metaSeqObject = newMRexperiment(data,phenoData = mtdata) #samples on the column and row has to be the feature
  metaSeqObject_CSS  = cumNorm( metaSeqObject , p = cumNormStatFast(metaSeqObject) )
  OTU_read_count_CSS = data.frame( MRcounts(metaSeqObject_CSS, norm = TRUE, log = TRUE))
  as.matrix(OTU_read_count_CSS)
}
```

```{r}
ft.css=css.pipeline(FEATURE_TABLE, METADATA.annotdf)
ft.imp.css = css.pipeline(ft.mbimpute.origlibsize, METADATA.annotdf)
```
Here we present, in order, results from CSS taking in input:
1. raw data
2. alr transformed data
3. clr transformed data
```{r}
head(ft.css[,1:5])
head(ft.imp.css[,1:5])
```


### Geometric Mean Pairwise Ratios (GMPR)

```{r}
gmpr.pipeline <- function(DATA){
  GMPR_factors<- GMPR(
    OTUmatrix = as.data.frame(t(DATA))
    , min_ct = 2
    , intersect_no = 4)
  data_normalized<- t(t(DATA)/GMPR_factors)
  data_normalized
}
```

```{r}
ft.gmpr=gmpr.pipeline(FEATURE_TABLE)
ft.imp.gmpr=gmpr.pipeline(ft.mbimpute.origlibsize)
head(ft.gmpr[,1:5])
head(ft.imp.gmpr[,1:5])
```
### Comparison
We noticed that the percentage of zeros in data matters in how and which methods to choose. In our data, we have a high percentage of zeros (%77) and referencing the paper Chen, Li et al. “GMPR: A robust normalization method for zero-inflated count...” paper, it is mentioned that GMPR has a better result than CSS or RLE.

# Differantial Abundance Methods
 
### ALDEx2
$\diamondsuit$ rab.all - median clr value for all samples in the feature
$\diamondsuit$ rab.win.NS - median clr value for the NS group of samples
$\diamondsuit$ rab.win.S - median clr value for the S group of samples
$\diamondsuit$ dif.btw - median difference in clr values between S and NS groups
$\diamondsuit$ dif.win - median of the largest difference in clr values within S and NS groups
$\diamondsuit$ effect - median effect size: diff.btw / max(diff.win) for all instances
$\diamondsuit$ overlap - proportion of effect size that overlaps 0 (i.e. no effect)
$\ast$ we.ep - Expected P value of Welch's t test
$\ast$ we.eBH - Expected Benjamini-Hochberg corrected P value of Welch's t test
$\ast$ wi.ep - Expected P value of Wilcoxon rank test
$\ast$ wi.eBH - Expected Benjamini-Hochberg corrected P value of Wilcoxon test

```{r, quiet=TRUE}
library(ALDEx2)
aldex.imp.gmpr <- aldex(reads = ceiling(ft.imp.gmpr), conditions =METADATA$DiseaseState, mc.samples = 128, test = "t")
aldex.imp.css<- aldex(reads = ceiling(ft.imp.css), conditions =METADATA$DiseaseState, mc.samples = 128, test = "t")
```


```{r, quiet=TRUE}
findDA <- function(data){
  qv=data$wi.eBH
  qv.largest=sort(unlist(qv))[which(sort(unlist(qv))>0.05)[1]-1]
  DA=data$wi.eBH <= qv.largest
  DA
}

DA.imp.gmpr <- findDA(aldex.imp.gmpr)
DA.imp.css<- findDA(aldex.imp.css)
```


```{r}
sum(DA.imp.gmpr)
sum(DA.imp.css)
```

### ANCOM-II

The method is not available in R, but you can download it from [GitHub](https://github.com/FrederickHuangLin/ANCOM) A copy is on stem. 

```{r message = FALSE}
source("ancom.R")
```


```{r, quiet=TRUE}
ancom.pipeline <- function(ft,METADATA){
  metadata<- data.frame("sample_id"=colnames(ft), "group"=METADATA$DiseaseState)
  
  prepro<- feature_table_pre_process(
    feature_table = ft
    , meta_data = metadata 
    , sample_var = "sample_id"
    , group_var = "group"
    , out_cut = 0.05
    , zero_cut = 0.9
    , lib_cut = 1000
    , neg_lb = T
    )
  
  prepro.data<- prepro$feature_table
  prepro.meta_data<- prepro$meta_data
  prepro.struc_zero<- prepro$structure_zeros

  ancom_results <- ANCOM(
    feature_table = prepro.data
    , meta_data = prepro.meta_data
    , struc_zero = prepro.struc_zero
    , main_var = "group"
    , p_adj_method = "BH"
    , alpha = 0.05)
  ancom_results
}
```

```{r, quiet=TRUE}
ancom.imp.gmpr=ancom.pipeline(ft.imp.gmpr, METADATA)
ancom.raw=ancom.pipeline(FEATURE_TABLE,METADATA)
ancom.gmpr=ancom.pipeline(ft.gmpr,METADATA)
```


```{r}
sum(ancom.raw$out$detected_0.7)
sum(ancom.gmpr$out$detected_0.7)
sum(ancom.imp.gmpr$out$detected_0.7)

```

```{r}
plot(ancom.raw$fig)
```
```{r}
plot(ancom.gmpr$fig)
```
```{r}
plot(ancom.imp.gmpr$fig)
```

```{r ancom_volcano}
ancom.raw$out
ancom.gmpr$out
ancom.imp.gmpr$out

```

Let's analyze the statistic W

```{r W-statistic}
plotW <- function(data){
  W_stat<- data$out$W[is.finite(data$out$W)]
  n_taxa<- length(W_stat) 
  
  
  plot(ecdf(W_stat[is.finite(W_stat)]), main ="Empirical cumulative distribution function for W ", xlab = "W")
  abline(v = n_taxa*0.6, col = "red")
  abline(v = n_taxa*0.7, col = "blue")
  abline(v = n_taxa*0.8, col = "green")
  abline(v = n_taxa*0.9, col = "orange")
  legend(30, 1, legend=c("detected_06", "detected_07", "detected_08", "detected_09"), 
         col=c("red", "blue", "green", "orange"), lty = 1)
}
plotW(ancom.raw)
plotW(ancom.gmpr)
plotW(ancom.imp.gmpr)
```


### Conclusions
Ancom removes taxa if considered outliers or DA because of a notable presence of zeroes in one of the groups. By applying imputation before DA analysis we can remove technical zeroes enhancing ANCOM performances.

Looking at the different taxa identified as DA we can see that ANCOM run with raw data and ANCOM run with GMPR normalized data gives almost the same results. Whether using mbImputed data the results are discordant (there are a total of 45 taxa considered DA in only one of the two run of ancom (ancom find around 60 DA taxa over the 166).
We can see also that 

```{r}
DA.withAllTaxa<- function(data, rn=rownames(FEATURE_TABLE)){
  vector.taxa=as.vector(rep(FALSE,length(rn)))
  listtaxa=rownames(FEATURE_TABLE)
  
  for(i in 1:length(data$out$taxa_id)){
    vector.taxa[which(listtaxa==data$out$taxa_id[i])]=data$out$detected_0.7[i]
  }
  vector.taxa
}
```

```{r, include=FALSE}
DA.imp.gmpr.ancom=DA.withAllTaxa(ancom.imp.gmpr)
DA.ancom=DA.withAllTaxa(ancom.raw)
DA.gmpr.ancom=DA.withAllTaxa(ancom.gmpr)
DA.imp.gmpr.ancom=DA.withAllTaxa(ancom.imp.gmpr)
```

```{r}
JacSim<- function(dat1,dat2){
  sum(dat1 & dat2)/sum(dat1 | dat2)
}



```

# Conclusion
### DA
We did the following experiments to see which combination of methods gave us a better result:

mbimpute + GMPR + Aldex

mbimpute + CSS + Aldex

mbimpute + GMPR + ANCOM-II

ANCOM-II

GMPR + ANCOM-II

Because ANCOM and ALDEX do CLR within their progress steps, we didn't apply CLR because more transformations might bias the results.

A few combinations without mbimpute have been tried to see how it affects our metadata to find DA.

Even in (mentioning the paper) we understood that GMPR works better than CSS, so we tried to use it as our normalization method rather than CSS.


# Data Visualisation
### All taxa

```{r}
# mbImpute gmpr aldex
data=FEATURE_TABLE
tsne(data,labels=METADATA$DiseaseState,perplex=10)

res.umap <- umap(t(data))
plot(res.umap$layout[,1],res.umap$layout[,2])
indCDI<-which(METADATA$DiseaseState=="CDI")
points(res.umap$layout[indCDI,1],res.umap$layout[indCDI,2],col=2)


res.nmds = metaMDS(t(data),distance="bray")
nmdsproj<-res.nmds$points
plot(nmdsproj[,1],nmdsproj[,2])
indCDI<-which(METADATA$DiseaseState=="CDI")
points(nmdsproj[indCDI,1],nmdsproj[indCDI,2],col=2)

```
### DA taxa
```{r}
# mbImpute gmpr aldex
data=ft.imp.gmpr
indices=DA.imp.gmpr
tsne(data[,indices],labels=METADATA$DiseaseState[indices],perplex=10)

res.umap <- umap(t(data[indices,]))
plot(res.umap$layout[,1],res.umap$layout[,2])
indCDI<-which(METADATA$DiseaseState[indices]=="CDI")
points(res.umap$layout[indCDI,1],res.umap$layout[indCDI,2],col=2)


res.nmds = metaMDS(t(data[indices,]),distance="bray")
nmdsproj<-res.nmds$points
plot(nmdsproj[,1],nmdsproj[,2])
indCDI<-which(METADATA$DiseaseState[indices]=="CDI")
points(nmdsproj[indCDI,1],nmdsproj[indCDI,2],col=2)

```
```{r}
# mbImpute css aldex
data=ft.imp.css
indices=DA.imp.css
tsne(data[,indices],labels=METADATA$DiseaseState[indices],perplex=10)

res.umap <- umap(t(data[indices,]))
plot(res.umap$layout[,1],res.umap$layout[,2])
indCDI<-which(METADATA$DiseaseState[indices]=="CDI")
points(res.umap$layout[indCDI,1],res.umap$layout[indCDI,2],col=2)


res.nmds = metaMDS(t(data[indices,]),distance="bray")
nmdsproj<-res.nmds$points
plot(nmdsproj[,1],nmdsproj[,2])
indCDI<-which(METADATA$DiseaseState[indices]=="CDI")
points(nmdsproj[indCDI,1],nmdsproj[indCDI,2],col=2)

```
```{r}
# mbImpute gmpr  ancom
data=ft.imp.gmpr
indices= DA.imp.gmpr.ancom
tsne(data[,indices],labels=METADATA$DiseaseState[indices],perplex=10)

res.umap <- umap(t(data[indices,]))
plot(res.umap$layout[,1],res.umap$layout[,2])
indCDI<-which(METADATA$DiseaseState[indices]=="CDI")
points(res.umap$layout[indCDI,1],res.umap$layout[indCDI,2],col=2)


res.nmds = metaMDS(t(data[indices,]),distance="bray")
nmdsproj<-res.nmds$points
plot(nmdsproj[,1],nmdsproj[,2])
indCDI<-which(METADATA$DiseaseState[indices]=="CDI")
points(nmdsproj[indCDI,1],nmdsproj[indCDI,2],col=2)

```
```{r}
# gmpr  ancom
data=ft.gmpr
indices= DA.gmpr.ancom
tsne(data[,indices],labels=METADATA$DiseaseState[indices],perplex=10)

res.umap <- umap(t(data[indices,]))
plot(res.umap$layout[,1],res.umap$layout[,2])
indCDI<-which(METADATA$DiseaseState[indices]=="CDI")
points(res.umap$layout[indCDI,1],res.umap$layout[indCDI,2],col=2)


res.nmds = metaMDS(t(data[indices,]),distance="bray")
nmdsproj<-res.nmds$points
plot(nmdsproj[,1],nmdsproj[,2])
indCDI<-which(METADATA$DiseaseState[indices]=="CDI")
points(nmdsproj[indCDI,1],nmdsproj[indCDI,2],col=2)

```

```{r}
# gmpr  ancom
data=FEATURE_TABLE
indices= DA.ancom
tsne(data[,indices],labels=METADATA$DiseaseState[indices],perplex=10)

res.umap <- umap(t(data[indices,]))
plot(res.umap$layout[,1],res.umap$layout[,2])
indCDI<-which(METADATA$DiseaseState[indices]=="CDI")
points(res.umap$layout[indCDI,1],res.umap$layout[indCDI,2],col=2)


res.nmds = metaMDS(t(data[indices,]),distance="bray")
nmdsproj<-res.nmds$points
plot(nmdsproj[,1],nmdsproj[,2])
indCDI<-which(METADATA$DiseaseState[indices]=="CDI")
points(nmdsproj[indCDI,1],nmdsproj[indCDI,2],col=2)

```



